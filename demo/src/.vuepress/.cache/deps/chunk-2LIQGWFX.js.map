{
  "version": 3,
  "sources": ["../../../../node_modules/@khanacademy/simple-markdown/src/index.js", "../../../../node_modules/mermaid/src/rendering-util/handle-markdown-text.js", "../../../../node_modules/mermaid/src/rendering-util/createText.js"],
  "sourcesContent": ["/* eslint-disable prefer-spread, no-regex-spaces, no-unused-vars, guard-for-in, no-console, no-var */\n// @flow\n\n/**\n * Simple-Markdown\n * ===============\n *\n * Simple-Markdown's primary goal is to be easy to adapt. It aims\n * to be compliant with John Gruber's [Markdown Syntax page][1],\n * but compatiblity with other markdown implementations' edge-cases\n * will be sacrificed where it conflicts with simplicity or\n * extensibility.\n *\n * If your goal is to simply embed a standard markdown implementation\n * in your website, simple-markdown is probably not the best library\n * for you (although it should work). But if you have struggled to\n * customize an existing library to meet your needs, simple-markdown\n * might be able to help.\n *\n * Many of the regexes and original logic has been adapted from\n * the wonderful [marked.js](https://github.com/chjj/marked)\n */\n\n// Flow Type Definitions:\n\ntype Capture =\n    | (Array<string> & {index: number})\n    | (Array<string> & {index?: number});\n\ntype Attr = string | number | boolean | null | void;\n\ntype SingleASTNode = {\n    type: string,\n    [string]: any,\n};\n\ntype UnTypedASTNode = {\n    [string]: any,\n};\n\ntype ASTNode = SingleASTNode | Array<SingleASTNode>;\n\ntype State = {\n    key?: string | number | void,\n    inline?: ?boolean,\n    [string]: any,\n};\n\ntype ReactElement = React$Element<any>;\ntype ReactElements = React$Node;\n\ntype MatchFunction = {regex?: RegExp} & ((\n    source: string,\n    state: State,\n    prevCapture: string,\n) => ?Capture);\n\ntype Parser = (source: string, state?: ?State) => Array<SingleASTNode>;\n\ntype ParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => UnTypedASTNode | ASTNode;\n\ntype SingleNodeParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => UnTypedASTNode;\n\ntype Output<Result> = (node: ASTNode, state?: ?State) => Result;\n\ntype NodeOutput<Result> = (\n    node: SingleASTNode,\n    nestedOutput: Output<Result>,\n    state: State,\n) => Result;\n\ntype ArrayNodeOutput<Result> = (\n    node: Array<SingleASTNode>,\n    nestedOutput: Output<Result>,\n    state: State,\n) => Result;\n\ntype ReactOutput = Output<ReactElements>;\ntype ReactNodeOutput = NodeOutput<ReactElements>;\ntype HtmlOutput = Output<string>;\ntype HtmlNodeOutput = NodeOutput<string>;\n\ntype ParserRule = {\n    +order: number,\n    +match: MatchFunction,\n    +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n    +parse: ParseFunction,\n};\n\ntype SingleNodeParserRule = {\n    +order: number,\n    +match: MatchFunction,\n    +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n    +parse: SingleNodeParseFunction,\n};\n\ntype ReactOutputRule = {\n    // we allow null because some rules are never output results, and that's\n    // legal as long as no parsers return an AST node matching that rule.\n    // We don't use ? because this makes it be explicitly defined as either\n    // a valid function or null, so it can't be forgotten.\n    +react: ReactNodeOutput | null,\n};\n\ntype HtmlOutputRule = {\n    +html: HtmlNodeOutput | null,\n};\n\ntype ArrayRule = {\n    +react?: ArrayNodeOutput<ReactElements>,\n    +html?: ArrayNodeOutput<string>,\n    +[string]: ArrayNodeOutput<any>,\n};\n\ntype ParserRules = {\n    +Array?: ArrayRule,\n    +[type: string]: ParserRule,\n};\n\ntype OutputRules<Rule> = {\n    +Array?: ArrayRule,\n    +[type: string]: Rule,\n};\ntype Rules<OutputRule> = {\n    +Array?: ArrayRule,\n    +[type: string]: ParserRule & OutputRule,\n};\ntype ReactRules = {\n    +Array?: {\n        +react: ArrayNodeOutput<ReactElements>,\n    },\n    +[type: string]: ParserRule & ReactOutputRule,\n};\ntype HtmlRules = {\n    +Array?: {\n        +html: ArrayNodeOutput<string>,\n    },\n    +[type: string]: ParserRule & HtmlOutputRule,\n};\n\n// We want to clarify our defaultRules types a little bit more so clients can\n// reuse defaultRules built-ins. So we make some stronger guarantess when\n// we can:\ntype NonNullReactOutputRule = {\n    +react: ReactNodeOutput,\n};\ntype ElementReactOutputRule = {\n    +react: NodeOutput<ReactElement>,\n};\ntype TextReactOutputRule = {\n    +react: NodeOutput<string>,\n};\ntype NonNullHtmlOutputRule = {\n    +html: HtmlNodeOutput,\n};\n\ntype DefaultInRule = SingleNodeParserRule & ReactOutputRule & HtmlOutputRule;\ntype TextInOutRule = SingleNodeParserRule &\n    TextReactOutputRule &\n    NonNullHtmlOutputRule;\ntype LenientInOutRule = SingleNodeParserRule &\n    NonNullReactOutputRule &\n    NonNullHtmlOutputRule;\ntype DefaultInOutRule = SingleNodeParserRule &\n    ElementReactOutputRule &\n    NonNullHtmlOutputRule;\n\ntype DefaultRules = {\n    +Array: {\n        +react: ArrayNodeOutput<ReactElements>,\n        +html: ArrayNodeOutput<string>,\n    },\n    +heading: DefaultInOutRule,\n    +nptable: DefaultInRule,\n    +lheading: DefaultInRule,\n    +hr: DefaultInOutRule,\n    +codeBlock: DefaultInOutRule,\n    +fence: DefaultInRule,\n    +blockQuote: DefaultInOutRule,\n    +list: DefaultInOutRule,\n    +def: LenientInOutRule,\n    +table: DefaultInOutRule,\n    +tableSeparator: DefaultInRule,\n    +newline: TextInOutRule,\n    +paragraph: DefaultInOutRule,\n    +escape: DefaultInRule,\n    +autolink: DefaultInRule,\n    +mailto: DefaultInRule,\n    +url: DefaultInRule,\n    +link: DefaultInOutRule,\n    +image: DefaultInOutRule,\n    +reflink: DefaultInRule,\n    +refimage: DefaultInRule,\n    +em: DefaultInOutRule,\n    +strong: DefaultInOutRule,\n    +u: DefaultInOutRule,\n    +del: DefaultInOutRule,\n    +inlineCode: DefaultInOutRule,\n    +br: DefaultInOutRule,\n    +text: TextInOutRule,\n};\n\ntype RefNode = {\n    type: string,\n    content?: ASTNode,\n    target?: string,\n    title?: string,\n    alt?: string,\n};\n\n// End Flow Definitions\n\nvar CR_NEWLINE_R = /\\r\\n?/g;\nvar TAB_R = /\\t/g;\nvar FORMFEED_R = /\\f/g;\n\n/**\n * Turn various whitespace into easy-to-process whitespace\n */\nvar preprocess = function (source: string): string {\n    return source\n        .replace(CR_NEWLINE_R, \"\\n\")\n        .replace(FORMFEED_R, \"\")\n        .replace(TAB_R, \"    \");\n};\n\nvar populateInitialState = function (\n    givenState: ?State,\n    defaultState: ?State,\n): State {\n    var state: State = givenState || {};\n    if (defaultState != null) {\n        for (var prop in defaultState) {\n            // $FlowFixMe\n            if (Object.prototype.hasOwnProperty.call(defaultState, prop)) {\n                state[prop] = defaultState[prop];\n            }\n        }\n    }\n    return state;\n};\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @param {SimpleMarkdown.ParserRules} rules\n *     an object containing\n *     rule type -> {match, order, parse} objects\n *     (lower order is higher precedence)\n * @param {SimpleMarkdown.OptionalState} [defaultState]\n *\n * @returns {SimpleMarkdown.Parser}\n *     The resulting parse function, with the following parameters:\n *     @source: the input source string to be parsed\n *     @state: an optional object to be threaded through parse\n *         calls. Allows clients to add stateful operations to\n *         parsing, such as keeping track of how many levels deep\n *         some nesting is. For an example use-case, see passage-ref\n *         parsing in src/widgets/passage/passage-markdown.jsx\n */\nvar parserFor = function (rules: ParserRules, defaultState: ?State): Parser {\n    // Sorts rules in order of increasing order, then\n    // ascending rule name in case of ties.\n    var ruleList = Object.keys(rules).filter(function (type) {\n        var rule = rules[type];\n        if (rule == null || rule.match == null) {\n            return false;\n        }\n        var order = rule.order;\n        if (\n            (typeof order !== \"number\" || !isFinite(order)) &&\n            typeof console !== \"undefined\"\n        ) {\n            console.warn(\n                \"simple-markdown: Invalid order for rule `\" +\n                    type +\n                    \"`: \" +\n                    String(order),\n            );\n        }\n        return true;\n    });\n\n    ruleList.sort(function (typeA, typeB) {\n        var ruleA: ParserRule = (rules[typeA]: any);\n        var ruleB: ParserRule = (rules[typeB]: any);\n        var orderA = ruleA.order;\n        var orderB = ruleB.order;\n\n        // First sort based on increasing order\n        if (orderA !== orderB) {\n            return orderA - orderB;\n        }\n\n        var secondaryOrderA = ruleA.quality ? 0 : 1;\n        var secondaryOrderB = ruleB.quality ? 0 : 1;\n\n        if (secondaryOrderA !== secondaryOrderB) {\n            return secondaryOrderA - secondaryOrderB;\n\n            // Then based on increasing unicode lexicographic ordering\n        } else if (typeA < typeB) {\n            return -1;\n        } else if (typeA > typeB) {\n            return 1;\n        } else {\n            // Rules should never have the same name,\n            // but this is provided for completeness.\n            return 0;\n        }\n    });\n\n    var latestState: State;\n    var nestedParse: Parser = function (\n        source: string,\n        state: ?State,\n    ): Array<SingleASTNode> {\n        var result: Array<SingleASTNode> = [];\n        state = state || latestState;\n        latestState = state;\n        while (source) {\n            // store the best match, it's rule, and quality:\n            var ruleType = null;\n            var rule = null;\n            var capture = null;\n            var quality = NaN;\n\n            // loop control variables:\n            var i = 0;\n            var currRuleType = ruleList[0];\n\n            // $FlowFixMe\n            var currRule: ParserRule = rules[currRuleType];\n\n            do {\n                var currOrder = currRule.order;\n                var prevCaptureStr =\n                    state.prevCapture == null ? \"\" : state.prevCapture[0];\n                var currCapture = currRule.match(source, state, prevCaptureStr);\n\n                if (currCapture) {\n                    var currQuality = currRule.quality\n                        ? currRule.quality(currCapture, state, prevCaptureStr)\n                        : 0;\n                    // This should always be true the first time because\n                    // the initial quality is NaN (that's why there's the\n                    // condition negation).\n                    if (!(currQuality <= quality)) {\n                        ruleType = currRuleType;\n                        rule = currRule;\n                        capture = currCapture;\n                        quality = currQuality;\n                    }\n                }\n\n                // Move on to the next item.\n                // Note that this makes `currRule` be the next item\n                i++;\n                currRuleType = ruleList[i];\n                // $FlowFixMe\n                currRule = rules[currRuleType];\n            } while (\n                // keep looping while we're still within the ruleList\n                currRule &&\n                // if we don't have a match yet, continue\n                (!capture ||\n                    // or if we have a match, but the next rule is\n                    // at the same order, and has a quality measurement\n                    // functions, then this rule must have a quality\n                    // measurement function (since they are sorted before\n                    // those without), and we need to check if there is\n                    // a better quality match\n                    (currRule.order === currOrder && currRule.quality))\n            );\n\n            // TODO(aria): Write tests for these\n            if (rule == null || capture == null) {\n                throw new Error(\n                    \"Could not find a matching rule for the below \" +\n                        \"content. The rule with highest `order` should \" +\n                        \"always match content provided to it. Check \" +\n                        \"the definition of `match` for '\" +\n                        ruleList[ruleList.length - 1] +\n                        \"'. It seems to not match the following source:\\n\" +\n                        source,\n                );\n            }\n            if (capture.index) {\n                // If present and non-zero, i.e. a non-^ regexp result:\n                throw new Error(\n                    \"`match` must return a capture starting at index 0 \" +\n                        \"(the current parse index). Did you forget a ^ at the \" +\n                        \"start of the RegExp?\",\n                );\n            }\n\n            var parsed = rule.parse(capture, nestedParse, state);\n            // We maintain the same object here so that rules can\n            // store references to the objects they return and\n            // modify them later. (oops sorry! but this adds a lot\n            // of power--see reflinks.)\n            if (Array.isArray(parsed)) {\n                // $FlowFixMe\n                Array.prototype.push.apply(result, parsed);\n            } else {\n                if (parsed == null || typeof parsed !== \"object\") {\n                    throw new Error(\n                        `parse() function returned invalid parse result: '${parsed}'`,\n                    );\n                }\n\n                // We also let rules override the default type of\n                // their parsed node if they would like to, so that\n                // there can be a single output function for all links,\n                // even if there are several rules to parse them.\n                if (parsed.type == null) {\n                    // $FlowFixMe\n                    parsed.type = ruleType;\n                }\n                result.push(parsed);\n            }\n\n            state.prevCapture = capture;\n            source = source.substring(state.prevCapture[0].length);\n        }\n\n        // $FlowFixMe\n        return result;\n    };\n\n    var outerParse: Parser = function (\n        source: string,\n        state: ?State,\n    ): Array<SingleASTNode> {\n        latestState = populateInitialState(state, defaultState);\n        if (!latestState.inline && !latestState.disableAutoBlockNewlines) {\n            source = source + \"\\n\\n\";\n        }\n        // We store the previous capture so that match functions can\n        // use some limited amount of lookbehind. Lists use this to\n        // ensure they don't match arbitrary '- ' or '* ' in inline\n        // text (see the list rule for more information). This stores\n        // the full regex capture object, if there is one.\n        latestState.prevCapture = null;\n        return nestedParse(preprocess(source), latestState);\n    };\n\n    // $FlowFixMe\n    return outerParse;\n};\n\n// Creates a match function for an inline scoped element from a regex\nvar inlineRegex = function (regex: RegExp): MatchFunction {\n    var match = function (\n        source: string,\n        state: State,\n        prevCapture: string,\n    ): ?Capture {\n        if (state.inline) {\n            // $FlowFixMe\n            return regex.exec(source);\n        } else {\n            return null;\n        }\n    };\n    match.regex = regex;\n\n    return match;\n};\n\n// Creates a match function for a block scoped element from a regex\nvar blockRegex = function (regex: RegExp): MatchFunction {\n    // $FlowFixMe\n    var match: MatchFunction = function (source, state) {\n        if (state.inline) {\n            return null;\n        } else {\n            return regex.exec(source);\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function from a regex, ignoring block/inline scope\nvar anyScopeRegex = function (regex: RegExp): MatchFunction {\n    // $FlowFixMe\n    var match: MatchFunction = function (source, state) {\n        return regex.exec(source);\n    };\n    match.regex = regex;\n    return match;\n};\n\nvar TYPE_SYMBOL =\n    (typeof Symbol === \"function\" &&\n        Symbol.for &&\n        Symbol.for(\"react.element\")) ||\n    0xeac7;\n\nvar reactElement = function (\n    type: string,\n    key: string | number | null | void,\n    props: {[string]: any},\n): ReactElement {\n    var element: ReactElement = ({\n        $$typeof: TYPE_SYMBOL,\n        type: type,\n        key: key == null ? undefined : key,\n        ref: null,\n        props: props,\n        _owner: null,\n    }: any);\n    return element;\n};\n\n/** Returns a closed HTML tag.\n * @param {string} tagName - Name of HTML tag (eg. \"em\" or \"a\")\n * @param {string} content - Inner content of tag\n * @param {{ [attr: string]: SimpleMarkdown.Attr }} [attributes] - Optional extra attributes of tag as an object of key-value pairs\n *   eg. { \"href\": \"http://google.com\" }. Falsey attributes are filtered out.\n * @param {boolean} [isClosed] - boolean that controls whether tag is closed or not (eg. img tags).\n *   defaults to true\n */\nvar htmlTag = function (\n    tagName: string,\n    content: string,\n    attributes: ?{[any]: ?Attr},\n    isClosed: ?boolean,\n) {\n    attributes = attributes || {};\n    isClosed = typeof isClosed !== \"undefined\" ? isClosed : true;\n\n    var attributeString = \"\";\n    for (var attr in attributes) {\n        var attribute = attributes[attr];\n        // Removes falsey attributes\n        if (\n            // $FlowFixMe\n            Object.prototype.hasOwnProperty.call(attributes, attr) &&\n            attribute\n        ) {\n            attributeString +=\n                \" \" + sanitizeText(attr) + '=\"' + sanitizeText(attribute) + '\"';\n        }\n    }\n\n    var unclosedTag = \"<\" + tagName + attributeString + \">\";\n\n    if (isClosed) {\n        return unclosedTag + content + \"</\" + tagName + \">\";\n    } else {\n        return unclosedTag;\n    }\n};\n\nvar EMPTY_PROPS = {};\n\n/**\n * @param {string | null | undefined} url - url to sanitize\n * @returns {string | null} - url if safe, or null if a safe url could not be made\n */\nvar sanitizeUrl = function (url: ?string) {\n    if (url == null) {\n        return null;\n    }\n    try {\n        var prot = new URL(url, \"https://localhost\").protocol;\n        if (\n            prot.indexOf(\"javascript:\") === 0 ||\n            prot.indexOf(\"vbscript:\") === 0 ||\n            prot.indexOf(\"data:\") === 0\n        ) {\n            return null;\n        }\n    } catch (e) {\n        // invalid URLs should throw a TypeError\n        // see for instance: `new URL(\"\");`\n        return null;\n    }\n    return url;\n};\n\nvar SANITIZE_TEXT_R = /[<>&\"']/g;\nvar SANITIZE_TEXT_CODES = {\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    \"&\": \"&amp;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n    \"/\": \"&#x2F;\",\n    \"`\": \"&#96;\",\n};\n\nvar sanitizeText = function (text: Attr): string {\n    return String(text).replace(SANITIZE_TEXT_R, function (chr) {\n        return SANITIZE_TEXT_CODES[chr];\n    });\n};\n\nvar UNESCAPE_URL_R = /\\\\([^0-9A-Za-z\\s])/g;\n\nvar unescapeUrl = function (rawUrlString: string): string {\n    return rawUrlString.replace(UNESCAPE_URL_R, \"$1\");\n};\n\n/**\n * Parse some content with the parser `parse`, with state.inline\n * set to true. Useful for block elements; not generally necessary\n * to be used by inline elements (where state.inline is already true.\n */\nvar parseInline = function (\n    parse: Parser,\n    content: string,\n    state: State,\n): ASTNode {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = true;\n    var result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n\nvar parseBlock = function (\n    parse: Parser,\n    content: string,\n    state: State,\n): ASTNode {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = false;\n    var result = parse(content + \"\\n\\n\", state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n\nvar parseCaptureInline = function (\n    capture: Capture,\n    parse: Parser,\n    state: State,\n): UnTypedASTNode {\n    return {\n        content: parseInline(parse, capture[1], state),\n    };\n};\n\nvar ignoreCapture = function (): UnTypedASTNode {\n    return {};\n};\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nvar LIST_BULLET = \"(?:[*+-]|\\\\d+\\\\.)\";\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nvar LIST_ITEM_PREFIX = \"( *)(\" + LIST_BULLET + \") +\";\nvar LIST_ITEM_PREFIX_R = new RegExp(\"^\" + LIST_ITEM_PREFIX);\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nvar LIST_ITEM_R = new RegExp(\n    LIST_ITEM_PREFIX +\n        \"[^\\\\n]*(?:\\\\n\" +\n        \"(?!\\\\1\" +\n        LIST_BULLET +\n        \" )[^\\\\n]*)*(\\n|$)\",\n    \"gm\",\n);\nvar BLOCK_END_R = /\\n{2,}$/;\nvar INLINE_CODE_ESCAPE_BACKTICKS_R = /^ (?= *`)|(` *) $/g;\n// recognize the end of a paragraph block inside a list item:\n// two or more newlines at end end of the item\nvar LIST_BLOCK_END_R = BLOCK_END_R;\nvar LIST_ITEM_END_R = / *\\n+$/;\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nvar LIST_R = new RegExp(\n    \"^( *)(\" +\n        LIST_BULLET +\n        \") \" +\n        \"[\\\\s\\\\S]+?(?:\\n{2,}(?! )\" +\n        \"(?!\\\\1\" +\n        LIST_BULLET +\n        \" )\\\\n*\" +\n        // the \\\\s*$ here is so that we can parse the inside of nested\n        // lists, where our content might end before we receive two `\\n`s\n        \"|\\\\s*\\n*$)\",\n);\nvar LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\n\nvar TABLES = (function () {\n    // predefine regexes so we don't have to create them inside functions\n    // sure, regex literals should be fast, even inside functions, but they\n    // aren't in all browsers.\n    var TABLE_BLOCK_TRIM = /\\n+/g;\n    var TABLE_ROW_SEPARATOR_TRIM = /^ *\\| *| *\\| *$/g;\n    var TABLE_CELL_END_TRIM = / *$/;\n    var TABLE_RIGHT_ALIGN = /^ *-+: *$/;\n    var TABLE_CENTER_ALIGN = /^ *:-+: *$/;\n    var TABLE_LEFT_ALIGN = /^ *:-+ *$/;\n\n    // TODO: This needs a real type\n    type TableAlignment = any;\n\n    var parseTableAlignCapture = function (\n        alignCapture: string,\n    ): TableAlignment {\n        if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n            return \"right\";\n        } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n            return \"center\";\n        } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n            return \"left\";\n        } else {\n            return null;\n        }\n    };\n\n    var parseTableAlign = function (\n        source: string,\n        parse: Parser,\n        state: State,\n        trimEndSeparators: boolean,\n    ): Array<TableAlignment> {\n        if (trimEndSeparators) {\n            source = source.replace(TABLE_ROW_SEPARATOR_TRIM, \"\");\n        }\n        var alignText = source.trim().split(\"|\");\n        return alignText.map(parseTableAlignCapture);\n    };\n\n    var parseTableRow = function (\n        source: string,\n        parse: Parser,\n        state: State,\n        trimEndSeparators: boolean,\n    ): Array<Array<SingleASTNode>> {\n        var prevInTable = state.inTable;\n        state.inTable = true;\n        var tableRow = parse(source.trim(), state);\n        state.inTable = prevInTable;\n\n        var cells = [[]];\n        tableRow.forEach(function (node, i) {\n            if (node.type === \"tableSeparator\") {\n                // Filter out empty table separators at the start/end:\n                if (\n                    !trimEndSeparators ||\n                    (i !== 0 && i !== tableRow.length - 1)\n                ) {\n                    // Split the current row:\n                    cells.push([]);\n                }\n            } else {\n                if (\n                    node.type === \"text\" &&\n                    (tableRow[i + 1] == null ||\n                        tableRow[i + 1].type === \"tableSeparator\")\n                ) {\n                    node.content = node.content.replace(\n                        TABLE_CELL_END_TRIM,\n                        \"\",\n                    );\n                }\n                cells[cells.length - 1].push(node);\n            }\n        });\n\n        return cells;\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.ASTNode[][]}\n     */\n    var parseTableCells = function (\n        source: string,\n        parse: Parser,\n        state: State,\n        trimEndSeparators: boolean,\n    ): Array<Array<ASTNode>> {\n        var rowsText = source.trim().split(\"\\n\");\n\n        return rowsText.map(function (rowText) {\n            // $FlowFixMe\n            return parseTableRow(rowText, parse, state, trimEndSeparators);\n        });\n    };\n\n    /**\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.SingleNodeParseFunction}\n     */\n    var parseTable = function (trimEndSeparators) {\n        return function (capture, parse, state) {\n            state.inline = true;\n            var header = parseTableRow(\n                capture[1],\n                parse,\n                state,\n                trimEndSeparators,\n            );\n            var align = parseTableAlign(\n                capture[2],\n                parse,\n                state,\n                trimEndSeparators,\n            );\n            var cells = parseTableCells(\n                capture[3],\n                parse,\n                state,\n                trimEndSeparators,\n            );\n            state.inline = false;\n\n            return {\n                type: \"table\",\n                header: header,\n                align: align,\n                cells: cells,\n            };\n        };\n    };\n\n    return {\n        parseTable: parseTable(true),\n        parseNpTable: parseTable(false),\n        TABLE_REGEX:\n            /^ *(\\|.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n        NPTABLE_REGEX:\n            /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\n    };\n})();\n\nvar LINK_INSIDE = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\";\nvar LINK_HREF_AND_TITLE =\n    \"\\\\s*<?((?:\\\\([^)]*\\\\)|[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\";\nvar AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\n\nvar parseRef = function (\n    capture: Capture,\n    state: State,\n    refNode: RefNode,\n): RefNode {\n    var ref = (capture[2] || capture[1]).replace(/\\s+/g, \" \").toLowerCase();\n\n    // We store information about previously seen defs on\n    // state._defs (_ to deconflict with client-defined\n    // state). If the def for this reflink/refimage has\n    // already been seen, we can use its target/source\n    // and title here:\n    if (state._defs && state._defs[ref]) {\n        var def = state._defs[ref];\n        // `refNode` can be a link or an image. Both use\n        // target and title properties.\n        refNode.target = def.target;\n        refNode.title = def.title;\n    }\n\n    // In case we haven't seen our def yet (or if someone\n    // overwrites that def later on), we add this node\n    // to the list of ref nodes for that def. Then, when\n    // we find the def, we can modify this link/image AST\n    // node :).\n    // I'm sorry.\n    state._refs = state._refs || {};\n    state._refs[ref] = state._refs[ref] || [];\n    state._refs[ref].push(refNode);\n\n    return refNode;\n};\n\nvar currOrder = 0;\n\nvar defaultRules: DefaultRules = {\n    Array: {\n        react: function (arr, output, state) {\n            var oldKey = state.key;\n            var result: Array<ReactElements> = [];\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0, key = 0; i < arr.length; i++, key++) {\n                // `key` is our numerical `state.key`, which we increment for\n                // every output node, but don't change for joined text nodes.\n                // (i, however, must change for joined text nodes)\n                state.key = \"\" + i;\n\n                var node = arr[i];\n                if (node.type === \"text\") {\n                    node = {type: \"text\", content: node.content};\n                    for (\n                        ;\n                        i + 1 < arr.length && arr[i + 1].type === \"text\";\n                        i++\n                    ) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result.push(output(node, state));\n            }\n\n            state.key = oldKey;\n            return result;\n        },\n        html: function (arr, output, state) {\n            var result = \"\";\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0, key = 0; i < arr.length; i++) {\n                var node = arr[i];\n                if (node.type === \"text\") {\n                    node = {type: \"text\", content: node.content};\n                    for (\n                        ;\n                        i + 1 < arr.length && arr[i + 1].type === \"text\";\n                        i++\n                    ) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result += output(node, state);\n            }\n            return result;\n        },\n    },\n    heading: {\n        order: currOrder++,\n        match: blockRegex(/^ *(#{1,6})([^\\n]+?)#* *(?:\\n *)+\\n/),\n        parse: function (capture, parse, state) {\n            return {\n                level: capture[1].length,\n                content: parseInline(parse, capture[2].trim(), state),\n            };\n        },\n        react: function (node, output, state) {\n            return reactElement(\"h\" + node.level, state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"h\" + node.level, output(node.content, state));\n        },\n    },\n    nptable: {\n        order: currOrder++,\n        match: blockRegex(TABLES.NPTABLE_REGEX),\n        parse: TABLES.parseNpTable,\n        react: null,\n        html: null,\n    },\n    lheading: {\n        order: currOrder++,\n        match: blockRegex(/^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/),\n        parse: function (capture, parse, state) {\n            return {\n                type: \"heading\",\n                level: capture[2] === \"=\" ? 1 : 2,\n                content: parseInline(parse, capture[1], state),\n            };\n        },\n        react: null,\n        html: null,\n    },\n    hr: {\n        order: currOrder++,\n        match: blockRegex(/^( *[-*_]){3,} *(?:\\n *)+\\n/),\n        parse: ignoreCapture,\n        react: function (node, output, state) {\n            return reactElement(\"hr\", state.key, EMPTY_PROPS);\n        },\n        html: function (node, output, state) {\n            return \"<hr>\";\n        },\n    },\n    codeBlock: {\n        order: currOrder++,\n        match: blockRegex(/^(?:    [^\\n]+\\n*)+(?:\\n *)+\\n/),\n        parse: function (capture, parse, state) {\n            var content = capture[0].replace(/^    /gm, \"\").replace(/\\n+$/, \"\");\n            return {\n                lang: undefined,\n                content: content,\n            };\n        },\n        react: function (node, output, state) {\n            var className = node.lang\n                ? \"markdown-code-\" + node.lang\n                : undefined;\n\n            return reactElement(\"pre\", state.key, {\n                children: reactElement(\"code\", null, {\n                    className: className,\n                    children: node.content,\n                }),\n            });\n        },\n        html: function (node, output, state) {\n            var className = node.lang\n                ? \"markdown-code-\" + node.lang\n                : undefined;\n\n            var codeBlock = htmlTag(\"code\", sanitizeText(node.content), {\n                class: className,\n            });\n            return htmlTag(\"pre\", codeBlock);\n        },\n    },\n    fence: {\n        order: currOrder++,\n        match: blockRegex(\n            /^ *(`{3,}|~{3,}) *(?:(\\S+) *)?\\n([\\s\\S]+?)\\n?\\1 *(?:\\n *)+\\n/,\n        ),\n        parse: function (capture, parse, state) {\n            return {\n                type: \"codeBlock\",\n                lang: capture[2] || undefined,\n                content: capture[3],\n            };\n        },\n        react: null,\n        html: null,\n    },\n    blockQuote: {\n        order: currOrder++,\n        match: blockRegex(/^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/),\n        parse: function (capture, parse, state) {\n            var content = capture[0].replace(/^ *> ?/gm, \"\");\n            return {\n                content: parse(content, state),\n            };\n        },\n        react: function (node, output, state) {\n            return reactElement(\"blockquote\", state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"blockquote\", output(node.content, state));\n        },\n    },\n    list: {\n        order: currOrder++,\n        // $FlowFixMe\n        match: function (source, state) {\n            // We only want to break into a list if we are at the start of a\n            // line. This is to avoid parsing \"hi * there\" with \"* there\"\n            // becoming a part of a list.\n            // You might wonder, \"but that's inline, so of course it wouldn't\n            // start a list?\". You would be correct! Except that some of our\n            // lists can be inline, because they might be inside another list,\n            // in which case we can parse with inline scope, but need to allow\n            // nested lists inside this inline scope.\n            var prevCaptureStr =\n                state.prevCapture == null ? \"\" : state.prevCapture[0];\n            var isStartOfLineCapture = LIST_LOOKBEHIND_R.exec(prevCaptureStr);\n            var isListBlock = state._list || !state.inline;\n\n            if (isStartOfLineCapture && isListBlock) {\n                source = isStartOfLineCapture[1] + source;\n                return LIST_R.exec(source);\n            } else {\n                return null;\n            }\n        },\n        parse: function (capture, parse, state) {\n            var bullet = capture[2];\n            var ordered = bullet.length > 1;\n            var start = ordered ? +bullet : undefined;\n            var items: Array<string> = capture[0]\n                .replace(LIST_BLOCK_END_R, \"\\n\")\n                .match(LIST_ITEM_R);\n\n            // We know this will match here, because of how the regexes are\n            // defined\n\n            var lastItemWasAParagraph = false;\n            var itemContent = items.map(function (item: string, i: number) {\n                // We need to see how far indented this item is:\n                var prefixCapture = LIST_ITEM_PREFIX_R.exec(item);\n                var space = prefixCapture ? prefixCapture[0].length : 0;\n                // And then we construct a regex to \"unindent\" the subsequent\n                // lines of the items by that amount:\n                var spaceRegex = new RegExp(\"^ {1,\" + space + \"}\", \"gm\");\n\n                // Before processing the item, we need a couple things\n                var content = item\n                    // remove indents on trailing lines:\n                    .replace(spaceRegex, \"\")\n                    // remove the bullet:\n                    .replace(LIST_ITEM_PREFIX_R, \"\");\n\n                // I'm not sur4 why this is necessary again?\n\n                // Handling \"loose\" lists, like:\n                //\n                //  * this is wrapped in a paragraph\n                //\n                //  * as is this\n                //\n                //  * as is this\n                var isLastItem = i === items.length - 1;\n                var containsBlocks = content.indexOf(\"\\n\\n\") !== -1;\n\n                // Any element in a list is a block if it contains multiple\n                // newlines. The last element in the list can also be a block\n                // if the previous item in the list was a block (this is\n                // because non-last items in the list can end with \\n\\n, but\n                // the last item can't, so we just \"inherit\" this property\n                // from our previous element).\n                var thisItemIsAParagraph =\n                    containsBlocks || (isLastItem && lastItemWasAParagraph);\n                lastItemWasAParagraph = thisItemIsAParagraph;\n\n                // backup our state for restoration afterwards. We're going to\n                // want to set state._list to true, and state.inline depending\n                // on our list's looseness.\n                var oldStateInline = state.inline;\n                var oldStateList = state._list;\n                state._list = true;\n\n                // Parse inline if we're in a tight list, or block if we're in\n                // a loose list.\n                var adjustedContent;\n                if (thisItemIsAParagraph) {\n                    state.inline = false;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\\n\\n\");\n                } else {\n                    state.inline = true;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\");\n                }\n\n                var result = parse(adjustedContent, state);\n\n                // Restore our state before returning\n                state.inline = oldStateInline;\n                state._list = oldStateList;\n                return result;\n            });\n\n            return {\n                ordered: ordered,\n                start: start,\n                items: itemContent,\n            };\n        },\n        react: function (node, output, state) {\n            var ListWrapper = node.ordered ? \"ol\" : \"ul\";\n\n            return reactElement(ListWrapper, state.key, {\n                start: node.start,\n                children: node.items.map(function (item: ASTNode, i: number) {\n                    return reactElement(\"li\", \"\" + i, {\n                        children: output(item, state),\n                    });\n                }),\n            });\n        },\n        html: function (node, output, state) {\n            var listItems = node.items\n                .map(function (item: ASTNode) {\n                    return htmlTag(\"li\", output(item, state));\n                })\n                .join(\"\");\n\n            var listTag = node.ordered ? \"ol\" : \"ul\";\n            var attributes = {\n                start: node.start,\n            };\n            return htmlTag(listTag, listItems, attributes);\n        },\n    },\n    def: {\n        order: currOrder++,\n        // TODO(aria): This will match without a blank line before the next\n        // block element, which is inconsistent with most of the rest of\n        // simple-markdown.\n        match: blockRegex(\n            /^ *\\[([^\\]]+)\\]: *<?([^\\s>]*)>?(?: +[\"(]([^\\n]+)[\")])? *\\n(?: *\\n)*/,\n        ),\n        parse: function (capture, parse, state) {\n            var def = capture[1].replace(/\\s+/g, \" \").toLowerCase();\n            var target = capture[2];\n            var title = capture[3];\n\n            // Look for previous links/images using this def\n            // If any links/images using this def have already been declared,\n            // they will have added themselves to the state._refs[def] list\n            // (_ to deconflict with client-defined state). We look through\n            // that list of reflinks for this def, and modify those AST nodes\n            // with our newly found information now.\n            // Sorry :(.\n            if (state._refs && state._refs[def]) {\n                // `refNode` can be a link or an image\n                state._refs[def].forEach(function (refNode: RefNode) {\n                    refNode.target = target;\n                    refNode.title = title;\n                });\n            }\n\n            // Add this def to our map of defs for any future links/images\n            // In case we haven't found any or all of the refs referring to\n            // this def yet, we add our def to the table of known defs, so\n            // that future reflinks can modify themselves appropriately with\n            // this information.\n            state._defs = state._defs || {};\n            state._defs[def] = {\n                target: target,\n                title: title,\n            };\n\n            // return the relevant parsed information\n            // for debugging only.\n            return {\n                def: def,\n                target: target,\n                title: title,\n            };\n        },\n        react: function () {\n            return null;\n        },\n        html: function () {\n            return \"\";\n        },\n    },\n    table: {\n        order: currOrder++,\n        match: blockRegex(TABLES.TABLE_REGEX),\n        parse: TABLES.parseTable,\n        react: function (node, output, state) {\n            var getStyle = function (colIndex: number): {\n                [attr: string]: Attr,\n            } {\n                return node.align[colIndex] == null\n                    ? {}\n                    : {\n                          textAlign: node.align[colIndex],\n                      };\n            };\n\n            var headers = node.header.map(function (\n                content: ASTNode,\n                i: number,\n            ) {\n                return reactElement(\"th\", \"\" + i, {\n                    style: getStyle(i),\n                    scope: \"col\",\n                    children: output(content, state),\n                });\n            });\n\n            var rows = node.cells.map(function (\n                row: Array<ASTNode>,\n                r: number,\n            ) {\n                return reactElement(\"tr\", \"\" + r, {\n                    children: row.map(function (content: ASTNode, c: number) {\n                        return reactElement(\"td\", \"\" + c, {\n                            style: getStyle(c),\n                            children: output(content, state),\n                        });\n                    }),\n                });\n            });\n\n            return reactElement(\"table\", state.key, {\n                children: [\n                    reactElement(\"thead\", \"thead\", {\n                        children: reactElement(\"tr\", null, {\n                            children: headers,\n                        }),\n                    }),\n                    reactElement(\"tbody\", \"tbody\", {\n                        children: rows,\n                    }),\n                ],\n            });\n        },\n        html: function (node, output, state) {\n            var getStyle = function (colIndex: number): string {\n                return node.align[colIndex] == null\n                    ? \"\"\n                    : \"text-align:\" + node.align[colIndex] + \";\";\n            };\n\n            var headers = node.header\n                .map(function (content: ASTNode, i: number) {\n                    return htmlTag(\"th\", output(content, state), {\n                        style: getStyle(i),\n                        scope: \"col\",\n                    });\n                })\n                .join(\"\");\n\n            var rows = node.cells\n                .map(function (row: Array<ASTNode>) {\n                    var cols = row\n                        .map(function (content: ASTNode, c: number) {\n                            return htmlTag(\"td\", output(content, state), {\n                                style: getStyle(c),\n                            });\n                        })\n                        .join(\"\");\n\n                    return htmlTag(\"tr\", cols);\n                })\n                .join(\"\");\n\n            var thead = htmlTag(\"thead\", htmlTag(\"tr\", headers));\n            var tbody = htmlTag(\"tbody\", rows);\n\n            return htmlTag(\"table\", thead + tbody);\n        },\n    },\n    newline: {\n        order: currOrder++,\n        match: blockRegex(/^(?:\\n *)*\\n/),\n        parse: ignoreCapture,\n        react: function (node, output, state) {\n            return \"\\n\";\n        },\n        html: function (node, output, state) {\n            return \"\\n\";\n        },\n    },\n    paragraph: {\n        order: currOrder++,\n        match: blockRegex(/^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/),\n        parse: parseCaptureInline,\n        react: function (node, output, state) {\n            return reactElement(\"div\", state.key, {\n                className: \"paragraph\",\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            var attributes = {\n                class: \"paragraph\",\n            };\n            return htmlTag(\"div\", output(node.content, state), attributes);\n        },\n    },\n    escape: {\n        order: currOrder++,\n        // We don't allow escaping numbers, letters, or spaces here so that\n        // backslashes used in plain text still get rendered. But allowing\n        // escaping anything else provides a very flexible escape mechanism,\n        // regardless of how this grammar is extended.\n        match: inlineRegex(/^\\\\([^0-9A-Za-z\\s])/),\n        parse: function (capture, parse, state) {\n            return {\n                type: \"text\",\n                content: capture[1],\n            };\n        },\n        react: null,\n        html: null,\n    },\n    tableSeparator: {\n        order: currOrder++,\n        // $FlowFixMe\n        match: function (source, state) {\n            if (!state.inTable) {\n                return null;\n            }\n            return /^ *\\| */.exec(source);\n        },\n        parse: function () {\n            return {type: \"tableSeparator\"};\n        },\n        // These shouldn't be reached, but in case they are, be reasonable:\n        react: function () {\n            return \" | \";\n        },\n        html: function () {\n            return \" &vert; \";\n        },\n    },\n    autolink: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^: >]+:\\/[^ >]+)>/),\n        parse: function (capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [\n                    {\n                        type: \"text\",\n                        content: capture[1],\n                    },\n                ],\n                target: capture[1],\n            };\n        },\n        react: null,\n        html: null,\n    },\n    mailto: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^ >]+@[^ >]+)>/),\n        parse: function (capture, parse, state) {\n            var address = capture[1];\n            var target = capture[1];\n\n            // Check for a `mailto:` already existing in the link:\n            if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n                target = \"mailto:\" + target;\n            }\n\n            return {\n                type: \"link\",\n                content: [\n                    {\n                        type: \"text\",\n                        content: address,\n                    },\n                ],\n                target: target,\n            };\n        },\n        react: null,\n        html: null,\n    },\n    url: {\n        order: currOrder++,\n        match: inlineRegex(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/),\n        parse: function (capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [\n                    {\n                        type: \"text\",\n                        content: capture[1],\n                    },\n                ],\n                target: capture[1],\n                title: undefined,\n            };\n        },\n        react: null,\n        html: null,\n    },\n    link: {\n        order: currOrder++,\n        match: inlineRegex(\n            new RegExp(\n                \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\",\n            ),\n        ),\n        parse: function (capture, parse, state) {\n            var link = {\n                content: parse(capture[1], state),\n                target: unescapeUrl(capture[2]),\n                title: capture[3],\n            };\n            return link;\n        },\n        react: function (node, output, state) {\n            return reactElement(\"a\", state.key, {\n                href: sanitizeUrl(node.target),\n                title: node.title,\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            var attributes = {\n                href: sanitizeUrl(node.target),\n                title: node.title,\n            };\n\n            return htmlTag(\"a\", output(node.content, state), attributes);\n        },\n    },\n    image: {\n        order: currOrder++,\n        match: inlineRegex(\n            new RegExp(\n                \"^!\\\\[(\" +\n                    LINK_INSIDE +\n                    \")\\\\]\\\\(\" +\n                    LINK_HREF_AND_TITLE +\n                    \"\\\\)\",\n            ),\n        ),\n        parse: function (capture, parse, state) {\n            var image = {\n                alt: capture[1],\n                target: unescapeUrl(capture[2]),\n                title: capture[3],\n            };\n            return image;\n        },\n        react: function (node, output, state) {\n            return reactElement(\"img\", state.key, {\n                src: sanitizeUrl(node.target),\n                alt: node.alt,\n                title: node.title,\n            });\n        },\n        html: function (node, output, state) {\n            var attributes = {\n                src: sanitizeUrl(node.target),\n                alt: node.alt,\n                title: node.title,\n            };\n\n            return htmlTag(\"img\", \"\", attributes, false);\n        },\n    },\n    reflink: {\n        order: currOrder++,\n        match: inlineRegex(\n            new RegExp(\n                // The first [part] of the link\n                \"^\\\\[(\" +\n                    LINK_INSIDE +\n                    \")\\\\]\" +\n                    // The [ref] target of the link\n                    \"\\\\s*\\\\[([^\\\\]]*)\\\\]\",\n            ),\n        ),\n        parse: function (capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"link\",\n                content: parse(capture[1], state),\n            });\n        },\n        react: null,\n        html: null,\n    },\n    refimage: {\n        order: currOrder++,\n        match: inlineRegex(\n            new RegExp(\n                // The first [part] of the link\n                \"^!\\\\[(\" +\n                    LINK_INSIDE +\n                    \")\\\\]\" +\n                    // The [ref] target of the link\n                    \"\\\\s*\\\\[([^\\\\]]*)\\\\]\",\n            ),\n        ),\n        parse: function (capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"image\",\n                alt: capture[1],\n            });\n        },\n        react: null,\n        html: null,\n    },\n    em: {\n        order: currOrder /* same as strong/u */,\n        match: inlineRegex(\n            new RegExp(\n                // only match _s surrounding words.\n                \"^\\\\b_\" +\n                    \"((?:__|\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\_])+?)_\" +\n                    \"\\\\b\" +\n                    // Or match *s:\n                    \"|\" +\n                    // Only match *s that are followed by a non-space:\n                    \"^\\\\*(?=\\\\S)(\" +\n                    // Match at least one of:\n                    \"(?:\" +\n                    //  - `**`: so that bolds inside italics don't close the\n                    //          italics\n                    \"\\\\*\\\\*|\" +\n                    //  - escape sequence: so escaped *s don't close us\n                    \"\\\\\\\\[\\\\s\\\\S]|\" +\n                    //  - whitespace: followed by a non-* (we don't\n                    //          want ' *' to close an italics--it might\n                    //          start a list)\n                    \"\\\\s+(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\s\\\\*\\\\\\\\]|\\\\*\\\\*)|\" +\n                    //  - non-whitespace, non-*, non-backslash characters\n                    \"[^\\\\s\\\\*\\\\\\\\]\" +\n                    \")+?\" +\n                    // followed by a non-space, non-* then *\n                    \")\\\\*(?!\\\\*)\",\n            ),\n        ),\n        quality: function (capture) {\n            // precedence by length, `em` wins ties:\n            return capture[0].length + 0.2;\n        },\n        parse: function (capture, parse, state) {\n            return {\n                content: parse(capture[2] || capture[1], state),\n            };\n        },\n        react: function (node, output, state) {\n            return reactElement(\"em\", state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"em\", output(node.content, state));\n        },\n    },\n    strong: {\n        order: currOrder /* same as em */,\n        match: inlineRegex(/^\\*\\*((?:\\\\[\\s\\S]|[^\\\\])+?)\\*\\*(?!\\*)/),\n        quality: function (capture) {\n            // precedence by length, wins ties vs `u`:\n            return capture[0].length + 0.1;\n        },\n        parse: parseCaptureInline,\n        react: function (node, output, state) {\n            return reactElement(\"strong\", state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"strong\", output(node.content, state));\n        },\n    },\n    u: {\n        order: currOrder++ /* same as em&strong; increment for next rule */,\n        match: inlineRegex(/^__((?:\\\\[\\s\\S]|[^\\\\])+?)__(?!_)/),\n        quality: function (capture) {\n            // precedence by length, loses all ties\n            return capture[0].length;\n        },\n        parse: parseCaptureInline,\n        react: function (node, output, state) {\n            return reactElement(\"u\", state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"u\", output(node.content, state));\n        },\n    },\n    del: {\n        order: currOrder++,\n        match: inlineRegex(\n            /^~~(?=\\S)((?:\\\\[\\s\\S]|~(?!~)|[^\\s~\\\\]|\\s(?!~~))+?)~~/,\n        ),\n        parse: parseCaptureInline,\n        react: function (node, output, state) {\n            return reactElement(\"del\", state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"del\", output(node.content, state));\n        },\n    },\n    inlineCode: {\n        order: currOrder++,\n        match: inlineRegex(/^(`+)([\\s\\S]*?[^`])\\1(?!`)/),\n        parse: function (capture, parse, state) {\n            return {\n                content: capture[2].replace(\n                    INLINE_CODE_ESCAPE_BACKTICKS_R,\n                    \"$1\",\n                ),\n            };\n        },\n        react: function (node, output, state) {\n            return reactElement(\"code\", state.key, {\n                children: node.content,\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"code\", sanitizeText(node.content));\n        },\n    },\n    br: {\n        order: currOrder++,\n        match: anyScopeRegex(/^ {2,}\\n/),\n        parse: ignoreCapture,\n        react: function (node, output, state) {\n            return reactElement(\"br\", state.key, EMPTY_PROPS);\n        },\n        html: function (node, output, state) {\n            return \"<br>\";\n        },\n    },\n    text: {\n        order: currOrder++,\n        // Here we look for anything followed by non-symbols,\n        // double newlines, or double-space-newlines\n        // We break on any symbol characters so that this grammar\n        // is easy to extend without needing to modify this regex\n        match: anyScopeRegex(\n            /^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/,\n        ),\n        parse: function (capture, parse, state) {\n            return {\n                content: capture[0],\n            };\n        },\n        react: function (node, output, state) {\n            return node.content;\n        },\n        html: function (node, output, state) {\n            return sanitizeText(node.content);\n        },\n    },\n};\n\n/** (deprecated) */\nvar ruleOutput = function (\n    // $FlowFixMe\n    rules: OutputRules<Rule>,\n    property: $Keys<Rule>,\n) {\n    if (!property && typeof console !== \"undefined\") {\n        console.warn(\n            \"simple-markdown ruleOutput should take 'react' or \" +\n                \"'html' as the second argument.\",\n        );\n    }\n\n    var nestedRuleOutput = function (\n        ast: SingleASTNode,\n        outputFunc: Output<any>,\n        state: State,\n    ) {\n        return rules[ast.type][property](ast, outputFunc, state);\n    };\n    return nestedRuleOutput;\n};\n\n/** (deprecated)\n */\nvar reactFor = function (outputFunc: ReactNodeOutput): ReactOutput {\n    var nestedOutput: ReactOutput = function (ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            var oldKey = state.key;\n            var result: Array<ReactElements> = [];\n\n            // map nestedOutput over the ast, except group any text\n            // nodes together into a single string output.\n            var lastResult = null;\n            for (var i = 0; i < ast.length; i++) {\n                state.key = \"\" + i;\n                var nodeOut = nestedOutput(ast[i], state);\n                if (\n                    typeof nodeOut === \"string\" &&\n                    typeof lastResult === \"string\"\n                ) {\n                    lastResult = lastResult + nodeOut;\n                    result[result.length - 1] = lastResult;\n                } else {\n                    result.push(nodeOut);\n                    lastResult = nodeOut;\n                }\n            }\n\n            state.key = oldKey;\n            return result;\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\n/** (deprecated)\n */\nvar htmlFor = function (outputFunc: HtmlNodeOutput): HtmlOutput {\n    var nestedOutput: HtmlOutput = function (ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            return ast\n                .map(function (node) {\n                    return nestedOutput(node, state);\n                })\n                .join(\"\");\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\nvar outputFor = function (\n    rules: OutputRules<Rule>,\n    property: $Keys<Rule>,\n    defaultState: ?State = {},\n) {\n    if (!property) {\n        throw new Error(\n            \"simple-markdown: outputFor: `property` must be \" +\n                \"defined. \" +\n                \"if you just upgraded, you probably need to replace `outputFor` \" +\n                \"with `reactFor`\",\n        );\n    }\n\n    var latestState: State;\n    // $FlowFixMe[incompatible-type]\n    var arrayRule: ArrayRule = rules.Array || defaultRules.Array;\n\n    // Tricks to convince tsc that this var is not null:\n    var arrayRuleCheck = arrayRule[property];\n    if (!arrayRuleCheck) {\n        throw new Error(\n            \"simple-markdown: outputFor: to join nodes of type `\" +\n                property +\n                \"` you must provide an `Array:` joiner rule with that type, \" +\n                \"Please see the docs for details on specifying an Array rule.\",\n        );\n    }\n    var arrayRuleOutput = arrayRuleCheck;\n\n    var nestedOutput: Output<any> = function (ast, state) {\n        state = state || latestState;\n        latestState = state;\n        if (Array.isArray(ast)) {\n            return arrayRuleOutput(ast, nestedOutput, state);\n        } else {\n            return rules[ast.type][property](ast, nestedOutput, state);\n        }\n    };\n\n    var outerOutput: Output<any> = function (ast, state) {\n        latestState = populateInitialState(state, defaultState);\n        return nestedOutput(ast, latestState);\n    };\n    return outerOutput;\n};\n\n// $FlowFixMe[incompatible-call]\nvar defaultRawParse = parserFor(defaultRules);\n\nvar defaultBlockParse = function (\n    source: string,\n    state: ?State,\n): Array<SingleASTNode> {\n    state = state || {};\n    state.inline = false;\n    return defaultRawParse(source, state);\n};\n\nvar defaultInlineParse = function (\n    source: string,\n    state: ?State,\n): Array<SingleASTNode> {\n    state = state || {};\n    state.inline = true;\n    return defaultRawParse(source, state);\n};\n\nvar defaultImplicitParse = function (\n    source: string,\n    state: ?State,\n): Array<SingleASTNode> {\n    var isBlock = BLOCK_END_R.test(source);\n    state = state || {};\n    state.inline = !isBlock;\n    return defaultRawParse(source, state);\n};\n\n// $FlowFixMe[incompatible-call]\nvar defaultReactOutput: ReactOutput = outputFor(defaultRules, \"react\");\n// $FlowFixMe[incompatible-call]\nvar defaultHtmlOutput: HtmlOutput = outputFor(defaultRules, \"html\");\n\nvar markdownToReact = function (source: string, state: ?State): ReactElements {\n    return defaultReactOutput(defaultBlockParse(source, state), state);\n};\n\nvar markdownToHtml = function (source: string, state: ?State): string {\n    return defaultHtmlOutput(defaultBlockParse(source, state), state);\n};\n\n// TODO: This needs definition\ntype ReactMarkdownProps = any;\nvar ReactMarkdown = function (props: ReactMarkdownProps): ReactElement {\n    var divProps = {};\n\n    for (var prop in props) {\n        if (\n            prop !== \"source\" &&\n            // $FlowFixMe\n            Object.prototype.hasOwnProperty.call(props, prop)\n        ) {\n            divProps[prop] = props[prop];\n        }\n    }\n    divProps.children = markdownToReact(props.source);\n\n    return reactElement(\"div\", null, divProps);\n};\n\ntype Exports = {\n    +defaultRules: DefaultRules,\n    +parserFor: (rules: ParserRules, defaultState?: ?State) => Parser,\n    +outputFor: <Rule: Object>(\n        rules: OutputRules<Rule>,\n        param: $Keys<Rule>,\n        defaultState?: ?State,\n    ) => Output<any>,\n\n    +ruleOutput: <Rule: Object>(\n        rules: OutputRules<Rule>,\n        param: $Keys<Rule>,\n    ) => NodeOutput<any>,\n    +reactFor: (ReactNodeOutput) => ReactOutput,\n    +htmlFor: (HtmlNodeOutput) => HtmlOutput,\n\n    +inlineRegex: (regex: RegExp) => MatchFunction,\n    +blockRegex: (regex: RegExp) => MatchFunction,\n    +anyScopeRegex: (regex: RegExp) => MatchFunction,\n    +parseInline: (parse: Parser, content: string, state: State) => ASTNode,\n    +parseBlock: (parse: Parser, content: string, state: State) => ASTNode,\n\n    +markdownToReact: (source: string, state?: ?State) => ReactElements,\n    +markdownToHtml: (source: string, state?: ?State) => string,\n    +ReactMarkdown: (props: {source: string, [string]: any}) => ReactElement,\n\n    +defaultRawParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultBlockParse: (\n        source: string,\n        state?: ?State,\n    ) => Array<SingleASTNode>,\n    +defaultInlineParse: (\n        source: string,\n        state?: ?State,\n    ) => Array<SingleASTNode>,\n    +defaultImplicitParse: (\n        source: string,\n        state?: ?State,\n    ) => Array<SingleASTNode>,\n\n    +defaultReactOutput: ReactOutput,\n    +defaultHtmlOutput: HtmlOutput,\n\n    +preprocess: (source: string) => string,\n    +sanitizeText: (text: Attr) => string,\n    +sanitizeUrl: (url: ?string) => ?string,\n    +unescapeUrl: (url: string) => string,\n    +htmlTag: (\n        tagName: string,\n        content: string,\n        attributes: ?{[any]: ?Attr},\n        isClosed: ?boolean,\n    ) => string,\n    +reactElement: (\n        type: string,\n        key: string | null,\n        props: {[string]: any},\n    ) => ReactElement,\n};\n\nexport type {\n    // Hopefully you shouldn't have to use these, but they're here if you need!\n    // Top-level API:\n    State,\n    Parser,\n    Output,\n    ReactOutput,\n    HtmlOutput,\n    // Most of the following types should be considered experimental and\n    // subject to change or change names. Again, they shouldn't be necessary,\n    // but if they are I'd love to hear how so I can better support them!\n\n    // Individual Rule fields:\n    Capture,\n    MatchFunction,\n    ParseFunction,\n    NodeOutput,\n    ArrayNodeOutput,\n    ReactNodeOutput,\n    // Single rules:\n    ParserRule,\n    ReactOutputRule,\n    HtmlOutputRule,\n    // Sets of rules:\n    ParserRules,\n    OutputRules,\n    Rules,\n    ReactRules,\n    HtmlRules,\n    SingleASTNode,\n};\n\n// $FlowFixMe\nvar SimpleMarkdown: Exports = {\n    defaultRules: defaultRules,\n    parserFor: parserFor,\n    outputFor: outputFor,\n\n    inlineRegex: inlineRegex,\n    blockRegex: blockRegex,\n    anyScopeRegex: anyScopeRegex,\n    parseInline: parseInline,\n    parseBlock: parseBlock,\n\n    // default wrappers:\n    markdownToReact: markdownToReact,\n    markdownToHtml: markdownToHtml,\n    ReactMarkdown: ReactMarkdown,\n\n    defaultBlockParse: defaultBlockParse,\n    defaultInlineParse: defaultInlineParse,\n    defaultImplicitParse: defaultImplicitParse,\n\n    defaultReactOutput: defaultReactOutput,\n    defaultHtmlOutput: defaultHtmlOutput,\n\n    preprocess: preprocess,\n    sanitizeText: sanitizeText,\n    sanitizeUrl: sanitizeUrl,\n    unescapeUrl: unescapeUrl,\n    htmlTag: htmlTag,\n    reactElement: reactElement,\n\n    // deprecated:\n    defaultRawParse: defaultRawParse,\n    ruleOutput: ruleOutput,\n    reactFor: reactFor,\n    htmlFor: htmlFor,\n\n    defaultParse: function () {\n        if (typeof console !== \"undefined\") {\n            console.warn(\n                \"defaultParse is deprecated, please use `defaultImplicitParse`\",\n            );\n        }\n        return defaultImplicitParse.apply(null, (arguments: any));\n    },\n    defaultOutput: function () {\n        if (typeof console !== \"undefined\") {\n            console.warn(\n                \"defaultOutput is deprecated, please use `defaultReactOutput`\",\n            );\n        }\n        return defaultReactOutput.apply(null, (arguments: any));\n    },\n};\n\nexport default SimpleMarkdown;\n", "import SimpleMarkdown from '@khanacademy/simple-markdown';\n\n/**\n *\n * @param markdown\n */\nfunction preprocessMarkdown(markdown) {\n  // Replace multiple newlines with a single newline\n  const withoutMultipleNewlines = markdown.replace(/\\n{2,}/g, '\\n');\n  // Remove extra spaces at the beginning of each line\n  const withoutExtraSpaces = withoutMultipleNewlines.replace(/^\\s+/gm, '');\n  return withoutExtraSpaces;\n}\n\n/**\n *\n * @param markdown\n */\nexport function markdownToLines(markdown) {\n  const preprocessedMarkdown = preprocessMarkdown(markdown);\n  const mdParse = SimpleMarkdown.defaultBlockParse;\n  const syntaxTree = mdParse(preprocessedMarkdown);\n\n  let lines = [[]];\n  let currentLine = 0;\n\n  /**\n   *\n   * @param node\n   * @param parentType\n   */\n  function processNode(node, parentType) {\n    if (node.type === 'text') {\n      const textLines = node.content.split('\\n');\n\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n\n        // textLine.split(/ (?=[^!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~]+)/).forEach((word) => {\n        textLine.split(' ').forEach((word) => {\n          if (word) {\n            lines[currentLine].push({ content: word, type: parentType || 'normal' });\n          }\n        });\n      });\n    } else if (node.type === 'strong' || node.type === 'em') {\n      node.content.forEach((contentNode) => {\n        processNode(contentNode, node.type);\n      });\n    }\n  }\n\n  syntaxTree.forEach((treeNode) => {\n    if (treeNode.type === 'paragraph') {\n      treeNode.content.forEach((contentNode) => {\n        processNode(contentNode);\n      });\n    }\n  });\n\n  return lines;\n}\n\n/**\n *\n * @param markdown\n */\nexport function markdownToHTML(markdown) {\n  const mdParse = SimpleMarkdown.defaultBlockParse;\n  const syntaxTree = mdParse(markdown);\n\n  /**\n   *\n   * @param node\n   */\n  function output(node) {\n    if (node.type === 'text') {\n      return node.content.replace(/\\n/g, '<br/>');\n    } else if (node.type === 'strong') {\n      return `<strong>${node.content.map(output).join('')}</strong>`;\n    } else if (node.type === 'em') {\n      return `<em>${node.content.map(output).join('')}</em>`;\n    } else if (node.type === 'paragraph') {\n      return `<p>${node.content.map(output).join('')}</p>`;\n    } else {\n      return '';\n    }\n  }\n\n  return syntaxTree.map(output).join('');\n}\n", "import { select } from 'd3';\nimport { log } from '../logger';\nimport { getConfig } from '../config';\nimport { evaluate } from '../diagrams/common/common';\nimport { decodeEntities } from '../mermaidAPI';\nimport { markdownToHTML, markdownToLines } from '../rendering-util/handle-markdown-text';\n/**\n * @param dom\n * @param styleFn\n */\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr('style', styleFn);\n  }\n}\n\n/**\n * @param element\n * @param {any} node\n * @param width\n * @param classes\n * @returns {SVGForeignObjectElement} Node\n */\nfunction addHtmlSpan(element, node, width, classes) {\n  const fo = element.append('foreignObject');\n  // const newEl = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');\n  // const newEl = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');\n  const div = fo.append('xhtml:div');\n  // const div = body.append('div');\n  // const div = fo.append('div');\n\n  const label = node.label;\n  const labelClass = node.isNode ? 'nodeLabel' : 'edgeLabel';\n  div.html(\n    `<span class=\"${labelClass} ${classes}\" ` +\n      (node.labelStyle ? 'style=\"' + node.labelStyle + '\"' : '') +\n      '>' +\n      label +\n      '</span>'\n  );\n\n  applyStyle(div, node.labelStyle);\n  div.style('display', 'table-cell');\n  div.style('white-space', 'nowrap');\n  div.style('max-width', width + 'px');\n  div.attr('xmlns', 'http://www.w3.org/1999/xhtml');\n\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style('display', 'table');\n    div.style('white-space', 'break-spaces');\n    div.style('width', width + 'px');\n    bbox = div.node().getBoundingClientRect();\n  }\n\n  fo.style('width', bbox.width);\n  fo.style('height', bbox.height);\n\n  return fo.node();\n}\n\n/**\n * Creates a tspan element with the specified attributes for text positioning.\n *\n * @param {object} textElement - The parent text element to append the tspan element.\n * @param {number} lineIndex - The index of the current line in the structuredText array.\n * @param {number} lineHeight - The line height value for the text.\n * @returns {object} The created tspan element.\n */\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement\n    .append('tspan')\n    .attr('class', 'text-outer-tspan')\n    .attr('x', 0)\n    .attr('y', lineIndex * lineHeight - 0.1 + 'em')\n    .attr('dy', lineHeight + 'em');\n}\n\n/**\n * Creates a formatted text element by breaking lines and applying styles based on\n * the given structuredText.\n *\n * @param {number} width - The maximum allowed width of the text.\n * @param {object} g - The parent group element to append the formatted text.\n * @param {Array} structuredText - The structured text data to format.\n * @param addBackground\n */\nfunction createFormattedText(width, g, structuredText, addBackground = false) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append('g');\n  let bkg = labelGroup.insert('rect').attr('class', 'background');\n  const textElement = labelGroup.append('text').attr('y', '-10.1');\n  // .attr('dominant-baseline', 'middle')\n  // .attr('text-anchor', 'middle');\n  // .attr('text-anchor', 'middle');\n  let lineIndex = -1;\n  structuredText.forEach((line) => {\n    lineIndex++;\n    let tspan = createTspan(textElement, lineIndex, lineHeight);\n\n    let words = [...line].reverse();\n    let currentWord;\n    let wrappedLine = [];\n\n    while (words.length) {\n      currentWord = words.pop();\n      wrappedLine.push(currentWord);\n\n      updateTextContentAndStyles(tspan, wrappedLine);\n\n      if (tspan.node().getComputedTextLength() > width) {\n        wrappedLine.pop();\n        words.push(currentWord);\n\n        updateTextContentAndStyles(tspan, wrappedLine);\n\n        wrappedLine = [];\n        lineIndex++;\n        tspan = createTspan(textElement, lineIndex, lineHeight);\n      }\n    }\n  });\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg\n      .attr('x', -padding)\n      .attr('y', -padding)\n      .attr('width', bbox.width + 2 * padding)\n      .attr('height', bbox.height + 2 * padding);\n    // .style('fill', 'red');\n\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\n\n/**\n * Updates the text content and styles of the given tspan element based on the\n * provided wrappedLine data.\n *\n * @param {object} tspan - The tspan element to update.\n * @param {Array} wrappedLine - The line data to apply to the tspan element.\n */\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text('');\n\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan\n      .append('tspan')\n      .attr('font-style', word.type === 'em' ? 'italic' : 'normal')\n      .attr('class', 'text-inner-tspan')\n      .attr('font-weight', word.type === 'strong' ? 'bold' : 'normal');\n    const special = ['\"', \"'\", '.', ',', ':', ';', '!', '?', '(', ')', '[', ']', '{', '}'];\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(' ' + word.content);\n    }\n  });\n}\n\n/**\n *\n * @param el\n * @param {*} text\n * @param {*} param1\n * @param root0\n * @param root0.style\n * @param root0.isTitle\n * @param root0.classes\n * @param root0.useHtmlLabels\n * @param root0.isNode\n * @returns\n */\n// Note when using from flowcharts converting the API isNode means classes should be set accordingly. When using htmlLabels => to sett classes to'nodeLabel' when isNode=true otherwise 'edgeLabel'\n// When not using htmlLabels => to set classes to 'title-row' when isTitle=true otherwise 'title-row'\nexport const createText = (\n  el,\n  text = '',\n  {\n    style = '',\n    isTitle = false,\n    classes = '',\n    useHtmlLabels = true,\n    isNode = true,\n    width,\n    addSvgBackground = false,\n  } = {}\n) => {\n  log.info('createText', text, style, isTitle, classes, useHtmlLabels, isNode, addSvgBackground);\n  if (useHtmlLabels) {\n    // TODO: addHtmlLabel accepts a labelStyle. Do we possibly have that?\n    // text = text.replace(/\\\\n|\\n/g, '<br />');\n    const htmlText = markdownToHTML(text);\n    // log.info('markdo  wnToHTML' + text, markdownToHTML(text));\n    const node = {\n      isNode,\n      label: decodeEntities(htmlText).replace(\n        /fa[blrs]?:fa-[\\w-]+/g,\n        (s) => `<i class='${s.replace(':', ' ')}'></i>`\n      ),\n      labelStyle: style.replace('fill:', 'color:'),\n    };\n    let vertexNode = addHtmlSpan(el, node, width, classes);\n    return vertexNode;\n  } else {\n    const structuredText = markdownToLines(text);\n    const special = ['\"', \"'\", '.', ',', ':', ';', '!', '?', '(', ')', '[', ']', '{', '}'];\n    let lastWord;\n    structuredText.forEach((line) => {\n      line.forEach((word) => {\n        if (special.includes(word.content) && lastWord) {\n          lastWord.content += word.content;\n          word.content = '';\n        }\n        lastWord = word;\n      });\n    });\n    const svgLabel = createFormattedText(width, el, structuredText, addSvgBackground);\n    return svgLabel;\n  }\n};\n"],
  "mappings": "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",
  "names": ["CR_NEWLINE_R", "TAB_R", "FORMFEED_R", "preprocess", "source", "replace", "populateInitialState", "givenState", "defaultState", "state", "prop", "Object", "prototype", "hasOwnProperty", "call", "parserFor", "rules", "ruleList", "keys", "filter", "type", "rule", "match", "order", "isFinite", "console", "warn", "String", "sort", "typeA", "typeB", "ruleA", "ruleB", "orderA", "orderB", "secondaryOrderA", "quality", "secondaryOrderB", "latestState", "nestedParse", "result", "ruleType", "capture", "NaN", "i", "currRuleType", "currRule", "currOrder", "prevCaptureStr", "prevCapture", "currCapture", "currQuality", "Error", "length", "index", "parsed", "parse", "Array", "isArray", "push", "apply", "substring", "outerParse", "inline", "disableAutoBlockNewlines", "inlineRegex", "regex", "exec", "blockRegex", "anyScopeRegex", "TYPE_SYMBOL", "Symbol", "for", "reactElement", "key", "props", "element", "$$typeof", "undefined", "ref", "_owner", "htmlTag", "tagName", "content", "attributes", "isClosed", "attributeString", "attr", "attribute", "sanitizeText", "unclosedTag", "EMPTY_PROPS", "sanitizeUrl", "url", "prot", "URL", "protocol", "indexOf", "e", "SANITIZE_TEXT_R", "SANITIZE_TEXT_CODES", "text", "chr", "UNESCAPE_URL_R", "unescapeUrl", "rawUrlString", "parseInline", "isCurrentlyInline", "parseBlock", "parseCaptureInline", "ignoreCapture", "LIST_BULLET", "LIST_ITEM_PREFIX", "LIST_ITEM_PREFIX_R", "RegExp", "LIST_ITEM_R", "BLOCK_END_R", "INLINE_CODE_ESCAPE_BACKTICKS_R", "LIST_BLOCK_END_R", "LIST_ITEM_END_R", "LIST_R", "LIST_LOOKBEHIND_R", "TABLES", "TABLE_ROW_SEPARATOR_TRIM", "TABLE_CELL_END_TRIM", "TABLE_RIGHT_ALIGN", "TABLE_CENTER_ALIGN", "TABLE_LEFT_ALIGN", "parseTableAlignCapture", "alignCapture", "test", "parseTableAlign", "trimEndSeparators", "alignText", "trim", "split", "map", "parseTableRow", "prevInTable", "inTable", "tableRow", "cells", "forEach", "node", "parseTableCells", "rowsText", "rowText", "parseTable", "header", "align", "parseNpTable", "TABLE_REGEX", "NPTABLE_REGEX", "LINK_INSIDE", "LINK_HREF_AND_TITLE", "AUTOLINK_MAILTO_CHECK_R", "parseRef", "refNode", "toLowerCase", "_defs", "def", "target", "title", "_refs", "defaultRules", "react", "arr", "output", "oldKey", "html", "heading", "level", "children", "nptable", "lheading", "hr", "codeBlock", "lang", "className", "class", "fence", "blockQuote", "list", "isStartOfLineCapture", "isListBlock", "_list", "bullet", "ordered", "start", "items", "lastItemWasAParagraph", "itemContent", "item", "prefixCapture", "space", "spaceRegex", "isLastItem", "containsBlocks", "thisItemIsAParagraph", "oldStateInline", "oldStateList", "adjustedContent", "ListWrapper", "listItems", "join", "listTag", "table", "getStyle", "colIndex", "textAlign", "headers", "style", "scope", "rows", "row", "r", "c", "cols", "thead", "tbody", "newline", "paragraph", "escape", "tableSeparator", "autolink", "mailto", "address", "link", "href", "image", "alt", "src", "reflink", "refimage", "em", "strong", "u", "del", "inlineCode", "br", "ruleOutput", "property", "nestedRuleOutput", "ast", "outputFunc", "reactFor", "nestedOutput", "lastResult", "nodeOut", "htmlFor", "outputFor", "arrayRule", "arrayRuleCheck", "arrayRuleOutput", "outerOutput", "defaultRawParse", "defaultBlockParse", "defaultInlineParse", "defaultImplicitParse", "isBlock", "defaultReactOutput", "defaultHtmlOutput", "markdownToReact", "markdownToHtml", "ReactMarkdown", "divProps", "SimpleMarkdown", "defaultParse", "arguments", "defaultOutput"]
}
